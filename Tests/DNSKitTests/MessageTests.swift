// DNSKit
// Copyright (C) Ian Spence and other DNSKit Contributors
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

import XCTest
@testable import DNSKit

final class MessageTests: XCTestCase {
    func testParseHeader() throws {
        let data = Data([ 0xbb, 0x7c, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0e, 0x10, 0x00, 0x04, 0x5d, 0xb8, 0xd7, 0x0e, 0x00, 0x00, 0x29, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ])
        let header = try MessageHeader(messageData: data)
        
        /*
         Domain Name System (response)
             Transaction ID:
             Flags: 0x8180 Standard query response, No error
                 1... .... .... .... = Response: Message is a response
                 .000 0... .... .... = Opcode: Standard query (0)
                 .... .0.. .... .... = Authoritative: Server is not an authority for domain
                 .... ..0. .... .... = Truncated: Message is not truncated
                 .... ...1 .... .... = Recursion desired: Do query recursively
                 .... .... 1... .... = Recursion available: Server can do recursive queries
                 .... .... .0.. .... = Z: reserved (0)
                 .... .... ..0. .... = Answer authenticated: Answer/authority portion was not authenticated by the server
                 .... .... ...0 .... = Non-authenticated data: Unacceptable
                 .... .... .... 0000 = Reply code: No error (0)
             Questions: 1
             Answer RRs: 1
             Authority RRs: 0
             Additional RRs: 1
         */
        XCTAssertEqual(header.idNumber, 0xbb7c)
        XCTAssertEqual(header.isResponse, true)
        XCTAssertEqual(header.operationCode, 0)
        XCTAssertEqual(header.authoritativeAnswer, false)
        XCTAssertEqual(header.truncated, false)
        XCTAssertEqual(header.recursionDesired, true)
        XCTAssertEqual(header.recursionAvailable, true)
        XCTAssertEqual(header.authenticatedData, false)
        XCTAssertEqual(header.checkingDisabled, false)
        XCTAssertEqual(header.responseCode, 0)
        XCTAssertEqual(header.questionCount, 1)
        XCTAssertEqual(header.answerCount, 1)
        XCTAssertEqual(header.nameserverCount, 0)
        XCTAssertEqual(header.additionalCount, 1)
    }

    func testParseDNSAMessage() throws {
        let data = Data([ 0xa5, 0x9f, 0x81, 0x80, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x03, 0x64, 0x6e, 0x73, 0x06, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x00, 0x00, 0x01, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x04, 0x08, 0x08, 0x08, 0x08, 0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x04, 0x08, 0x08, 0x04, 0x04 ])
        let message = try Message(messageData: data)
        XCTAssertEqual(message.questions.count, 1)
        XCTAssertEqual(message.answers.count, 2)
        XCTAssertEqual(message.idNumber, 42399)
        XCTAssertEqual(message.questions[0].name, "dns.google.")
        XCTAssertEqual(message.answers[0].name, "dns.google.")
        XCTAssertEqual(message.answers[1].name, "dns.google.")
        XCTAssertEqual(message.answers[0].ttlSeconds, 42)
        XCTAssertEqual(message.answers[1].ttlSeconds, 42)
        XCTAssertEqual(message.answers[0].recordType, .A)
        XCTAssertEqual(message.answers[1].recordType, .A)
        guard let data1 = message.answers[0].data as? ARecordData else { fatalError("answer data incorrect type") }
        guard let data2 = message.answers[1].data as? ARecordData else { fatalError("answer data incorrect type") }
        XCTAssertEqual(data1.ipAddress, "8.8.8.8")
        XCTAssertEqual(data2.ipAddress, "8.8.4.4")
    }

    func testParseDNSNSMessage() throws {
        let data = Data([ 0x11, 0x7B, 0x81, 0x80, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x07, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x02, 0x00, 0x01, 0xC0, 0x0C, 0x00, 0x02, 0x00, 0x01, 0x00, 0x01, 0x19, 0x63, 0x00, 0x14, 0x01, 0x61, 0x0C, 0x69, 0x61, 0x6E, 0x61, 0x2D, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73, 0x03, 0x6E, 0x65, 0x74, 0x00, 0xC0, 0x0C, 0x00, 0x02, 0x00, 0x01, 0x00, 0x01, 0x19, 0x63, 0x00, 0x04, 0x01, 0x62, 0xC0, 0x2B ])
        let message = try Message(messageData: data)
        XCTAssertEqual(message.questions.count, 1)
        XCTAssertEqual(message.answers.count, 2)
        XCTAssertEqual(message.questions[0].name, "example.com.")
        XCTAssertEqual(message.answers[0].name, "example.com.")
        XCTAssertEqual(message.answers[1].name, "example.com.")
        XCTAssertEqual(message.answers[0].ttlSeconds, 72035)
        XCTAssertEqual(message.answers[1].ttlSeconds, 72035)
        XCTAssertEqual(message.answers[0].recordType, .NS)
        XCTAssertEqual(message.answers[1].recordType, .NS)
        guard let data1 = message.answers[0].data as? NSRecordData else { fatalError("answer data incorrect type") }
        guard let data2 = message.answers[1].data as? NSRecordData else { fatalError("answer data incorrect type") }
        XCTAssertEqual(data1.name, "a.iana-servers.net.")
        XCTAssertEqual(data2.name, "b.iana-servers.net.")
    }

    func testParseDNSAAAAMessage() throws {
        let data = Data([ 0x33, 0xb1, 0x81, 0x80, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x03, 0x64, 0x6e, 0x73, 0x06, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x00, 0x00, 0x1c, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x1c, 0x00, 0x01, 0x00, 0x00, 0x02, 0x5b, 0x00, 0x10, 0x20, 0x01, 0x48, 0x60, 0x48, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0xc0, 0x0c, 0x00, 0x1c, 0x00, 0x01, 0x00, 0x00, 0x02, 0x5b, 0x00, 0x10, 0x20, 0x01, 0x48, 0x60, 0x48, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x44 ])
        let message = try Message(messageData: data)
        XCTAssertEqual(message.questions.count, 1)
        XCTAssertEqual(message.answers.count, 2)
        XCTAssertEqual(message.questions[0].name, "dns.google.")
        XCTAssertEqual(message.answers[0].name, "dns.google.")
        XCTAssertEqual(message.answers[1].name, "dns.google.")
        XCTAssertEqual(message.answers[0].ttlSeconds, 603)
        XCTAssertEqual(message.answers[1].ttlSeconds, 603)
        XCTAssertEqual(message.answers[0].recordType, .AAAA)
        XCTAssertEqual(message.answers[1].recordType, .AAAA)
        guard let data1 = message.answers[0].data as? AAAARecordData else { fatalError("answer data incorrect type") }
        guard let data2 = message.answers[1].data as? AAAARecordData else { fatalError("answer data incorrect type") }
        XCTAssertEqual(data1.ipAddress, "2001:4860:4860::8888")
        XCTAssertEqual(data2.ipAddress, "2001:4860:4860::8844")
    }

    func testParseDNSCNAMEMessage() throws {
        let data = Data([ 0xdb, 0x15, 0x81, 0x80, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x05, 0x63, 0x6e, 0x61, 0x6d, 0x65, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00, 0x01, 0x2c, 0x00, 0x07, 0x04, 0x68, 0x6f, 0x73, 0x74, 0xc0, 0x12, 0xc0, 0x2f, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x2c, 0x00, 0x04, 0x7f, 0x00, 0x00, 0x01 ])
        let message = try Message(messageData: data)
        XCTAssertEqual(message.questions.count, 1)
        XCTAssertEqual(message.answers.count, 2)
        XCTAssertEqual(message.questions[0].name, "cname.example.com.")
        XCTAssertEqual(message.answers[0].name, "cname.example.com.")
        XCTAssertEqual(message.answers[1].name, "host.example.com.")
        XCTAssertEqual(message.answers[0].ttlSeconds, 300)
        XCTAssertEqual(message.answers[1].ttlSeconds, 300)
        XCTAssertEqual(message.answers[0].recordType, .CNAME)
        XCTAssertEqual(message.answers[1].recordType, .A)
        guard let data1 = message.answers[0].data as? CNAMERecordData else { fatalError("answer data incorrect type") }
        guard let data2 = message.answers[1].data as? ARecordData else { fatalError("answer data incorrect type") }
        XCTAssertEqual(data1.name, "host.example.com.")
        XCTAssertEqual(data2.ipAddress, "127.0.0.1")
    }

    func testParseDNSSOAMessage() throws {
        let data = Data([ 0x68, 0x39, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x06, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x0e, 0x10, 0x00, 0x2c, 0x02, 0x6e, 0x73, 0x05, 0x69, 0x63, 0x61, 0x6e, 0x6e, 0x03, 0x6f, 0x72, 0x67, 0x00, 0x03, 0x6e, 0x6f, 0x63, 0x03, 0x64, 0x6e, 0x73, 0xc0, 0x2c, 0x78, 0xa4, 0x6d, 0x5d, 0x00, 0x00, 0x1c, 0x20, 0x00, 0x00, 0x0e, 0x10, 0x00, 0x12, 0x75, 0x00, 0x00, 0x00, 0x0e, 0x10, 0x00, 0x00, 0x29, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ])
        let message = try Message(messageData: data)
        XCTAssertEqual(message.questions.count, 1)
        XCTAssertEqual(message.answers.count, 1)
        guard let data = message.answers[0].data as? SOARecordData else { fatalError("answer data incorrect type") }
        XCTAssertEqual(data.mname, "ns.icann.org.")
        XCTAssertEqual(data.rname, "noc@dns.icann.org.")
        XCTAssertEqual(data.serial, 2024041821)
        XCTAssertEqual(data.refresh, 7200)
        XCTAssertEqual(data.retry, 3600)
        XCTAssertEqual(data.expire, 1209600)
        XCTAssertEqual(data.minimum, 3600)
    }

    func testParseDNSMXMessage() throws {
        let data = Data([ 0xe3, 0x85, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x0f, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x0f, 0x00, 0x01, 0x00, 0x00, 0x01, 0x2c, 0x00, 0x09, 0x00, 0x0a, 0x04, 0x6d, 0x61, 0x69, 0x6c, 0xc0, 0x0c ])
        let message = try Message(messageData: data)
        XCTAssertEqual(message.questions.count, 1)
        XCTAssertEqual(message.answers.count, 1)
        XCTAssertEqual(message.questions[0].name, "example.com.")
        XCTAssertEqual(message.answers[0].name, "example.com.")
        XCTAssertEqual(message.answers[0].ttlSeconds, 300)
        XCTAssertEqual(message.answers[0].recordType, .MX)
        guard let data = message.answers[0].data as? MXRecordData else { fatalError("answer data incorrect type") }
        XCTAssertEqual(data.name, "mail.example.com.")
        XCTAssertEqual(data.priority, 10)
    }

    func testParseDNSSRVMessage() throws {
        let data = Data([ 0xb3, 0xbd, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x04, 0x5f, 0x74, 0x63, 0x70, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x21, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x21, 0x00, 0x01, 0x00, 0x00, 0x01, 0x2c, 0x00, 0x18, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x7b, 0x04, 0x68, 0x6f, 0x73, 0x74, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00 ])
        let message = try Message(messageData: data)
        XCTAssertEqual(message.questions.count, 1)
        XCTAssertEqual(message.answers.count, 1)
        XCTAssertEqual(message.questions[0].name, "_service._tcp.example.com.")
        XCTAssertEqual(message.answers[0].name, "_service._tcp.example.com.")
        XCTAssertEqual(message.answers[0].ttlSeconds, 300)
        XCTAssertEqual(message.answers[0].recordType, .SRV)
        guard let data = message.answers[0].data as? SRVRecordData else { fatalError("answer data incorrect type") }
        XCTAssertEqual(data.name, "host.example.com.")
        XCTAssertEqual(data.priority, 10)
        XCTAssertEqual(data.weight, 0)
        XCTAssertEqual(data.port, 123)
    }

    func testParseDNSPTRMessage() throws {
        let data = Data([ 0x46, 0xe7, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x31, 0x01, 0x30, 0x01, 0x30, 0x03, 0x31, 0x32, 0x37, 0x07, 0x69, 0x6e, 0x2d, 0x61, 0x64, 0x64, 0x72, 0x04, 0x61, 0x72, 0x70, 0x61, 0x00, 0x00, 0x0c, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x51, 0x80, 0x00, 0x0b, 0x09, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x68, 0x6f, 0x73, 0x74, 0x00 ])
        let message = try Message(messageData: data)
        XCTAssertEqual(message.questions.count, 1)
        XCTAssertEqual(message.answers.count, 1)
        XCTAssertEqual(message.questions[0].name, "1.0.0.127.in-addr.arpa.")
        XCTAssertEqual(message.answers[0].name, "1.0.0.127.in-addr.arpa.")
        XCTAssertEqual(message.answers[0].ttlSeconds, 86400)
        XCTAssertEqual(message.answers[0].recordType, .PTR)
        guard let data = message.answers[0].data as? PTRRecordData else { fatalError("answer data incorrect type") }
        XCTAssertEqual(data.name, "localhost.")
    }

    func testParseDNSTXTMessage() throws {
        let data = Data([ 0x0a, 0xbb, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x10, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x9d, 0x02, 0x53, 0xff, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x6f, 0x75, 0x72, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x20, 0x6e, 0x6f, 0x77, 0x2e, 0x2e, 0x2e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x72, 0x6f, 0x6e, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x65, 0x61, 0x75, 0x74, 0x79, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x61, 0x75, 0x64, 0x2e, 0x20, 0x20, 0x57, 0x65, 0x20, 0x6d, 0x61, 0x6b, 0x65, 0x20, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x20, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x61, 0x6c, 0x72, 0x65, 0x61, 0x64, 0x79, 0x20, 0x65, 0x78, 0x69, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6f, 0x75, 0x74, 0x20, 0x70, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x77, 0x68, 0x61, 0x74, 0x20, 0x63, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x64, 0x69, 0x72, 0x74, 0x2d, 0x63, 0x68, 0x65, 0x61, 0x70, 0x20, 0x69, 0x66, 0x20, 0x69, 0x74, 0x20, 0x77, 0x61, 0x73, 0x6e, 0x74, 0x20, 0x72, 0x75, 0x6e, 0x20, 0x62, 0x79, 0x20, 0x70, 0x72, 0x6f, 0x66, 0x69, 0x74, 0x65, 0x65, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x67, 0x6c, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x73, 0x2c, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x63, 0x61, 0x6c, 0x6c, 0x20, 0x75, 0x73, 0x20, 0x63, 0x72, 0x69, 0x6d, 0x69, 0x6e, 0x61, 0x6c, 0x73, 0x2e, 0x20, 0x20, 0x57, 0x65, 0x20, 0x65, 0x78, 0x70, 0x6c, 0xff, 0x6f, 0x72, 0x65, 0x2e, 0x2e, 0x2e, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x63, 0x61, 0x6c, 0x6c, 0x20, 0x75, 0x73, 0x20, 0x63, 0x72, 0x69, 0x6d, 0x69, 0x6e, 0x61, 0x6c, 0x73, 0x2e, 0x20, 0x20, 0x57, 0x65, 0x20, 0x73, 0x65, 0x65, 0x6b, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x6c, 0x65, 0x64, 0x67, 0x65, 0x2e, 0x2e, 0x2e, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x63, 0x61, 0x6c, 0x6c, 0x20, 0x75, 0x73, 0x20, 0x63, 0x72, 0x69, 0x6d, 0x69, 0x6e, 0x61, 0x6c, 0x73, 0x2e, 0x20, 0x20, 0x57, 0x65, 0x20, 0x65, 0x78, 0x69, 0x73, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6f, 0x75, 0x74, 0x20, 0x73, 0x6b, 0x69, 0x6e, 0x20, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x2c, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6f, 0x75, 0x74, 0x20, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x69, 0x74, 0x79, 0x2c, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6f, 0x75, 0x74, 0x20, 0x72, 0x65, 0x6c, 0x69, 0x67, 0x69, 0x6f, 0x75, 0x73, 0x20, 0x62, 0x69, 0x61, 0x73, 0x2e, 0x2e, 0x2e, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x63, 0x61, 0x6c, 0x6c, 0x20, 0x75, 0x73, 0x20, 0x63, 0x72, 0x69, 0x6d, 0x69, 0x6e, 0x61, 0x6c, 0x73, 0x2e, 0x20, 0x59, 0x6f, 0x75, 0x20, 0x62, 0x75, 0x69, 0x6c, 0x64, 0x20, 0x61, 0x74, 0x6f, 0x6d, 0x69, 0x63, 0x20, 0x62, 0x6f, 0x6d, 0x62, 0x73, 0x2c, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x77, 0x61, 0x67, 0x65, 0x20, 0x77, 0x61, 0x72, 0x73, 0x2c, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6d, 0x75, 0x72, 0x64, 0x65, 0x72, 0x2c, 0x20, 0x63, 0x68, 0x65, 0x61, 0x74, 0x2c, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x52, 0x6c, 0x69, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x75, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x72, 0x79, 0x20, 0x74, 0x6f, 0x20, 0x6d, 0x61, 0x6b, 0x65, 0x20, 0x75, 0x73, 0x20, 0x62, 0x65, 0x6c, 0x69, 0x65, 0x76, 0x65, 0x20, 0x69, 0x74, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x6f, 0x75, 0x72, 0x20, 0x6f, 0x77, 0x6e, 0x20, 0x67, 0x6f, 0x6f, 0x64, 0x2c, 0x20, 0x79, 0x65, 0x74, 0x20, 0x77, 0x65, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x72, 0x69, 0x6d, 0x69, 0x6e, 0x61, 0x6c, 0x73, 0x2e ])
        let message = try Message(messageData: data)
        XCTAssertEqual(message.questions.count, 1)
        XCTAssertEqual(message.answers.count, 1)
        XCTAssertEqual(message.questions[0].name, "example.com.")
        XCTAssertEqual(message.answers[0].name, "example.com.")
        XCTAssertEqual(message.answers[0].ttlSeconds, 157)
        XCTAssertEqual(message.answers[0].recordType, .TXT)
        guard let data = message.answers[0].data as? TXTRecordData else { fatalError("answer data incorrect type") }
        XCTAssertEqual(data.text, "This is our world now... the world of the electron and the switch, the beauty of the baud.  We make use of a service already existing without paying for what could be dirt-cheap if it wasnt run by profiteering gluttons, and you call us criminals.  We explore... and you call us criminals.  We seek after knowledge... and you call us criminals.  We exist without skin color, without nationality, without religious bias... and you call us criminals. You build atomic bombs, you wage wars, you murder, cheat, and lie to us and try to make us believe its for our own good, yet were the criminals.")
    }

    func testParseDNSNXDOMAINMessage() throws {
        let data = Data([ 0xbd, 0x25, 0x81, 0x83, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x19, 0x74, 0x68, 0x69, 0x73, 0x2d, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x2d, 0x64, 0x6f, 0x65, 0x73, 0x2d, 0x6e, 0x6f, 0x74, 0x2d, 0x65, 0x78, 0x69, 0x74, 0x02, 0x63, 0x61, 0x00, 0x00, 0x01, 0x00, 0x01, 0xc0, 0x26, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x0e, 0x10, 0x00, 0x37, 0x0a, 0x70, 0x72, 0x64, 0x2d, 0x63, 0x7a, 0x70, 0x2d, 0x30, 0x35, 0x04, 0x63, 0x6f, 0x72, 0x70, 0x04, 0x63, 0x69, 0x72, 0x61, 0xc0, 0x26, 0x09, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2d, 0x64, 0x6e, 0x73, 0xc0, 0x4a, 0x89, 0xbf, 0xfb, 0xb0, 0x00, 0x00, 0x08, 0x34, 0x00, 0x00, 0x03, 0x84, 0x00, 0x34, 0xbc, 0x00, 0x00, 0x00, 0x0e, 0x10 ])
        let message = try Message(messageData: data)
        XCTAssertEqual(message.responseCode, .NXDOMAIN)
        XCTAssertEqual(message.questions.count, 1)
        XCTAssertEqual(message.answers.count, 0)
        XCTAssertEqual(message.questions[0].name, "this-domain-does-not-exit.ca.")
    }

    func testParseDNSDNSKEYMessage() throws {
        let data = Data([ 0x98, 0x8b, 0x81, 0x80, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x30, 0x00, 0x01, 0x00, 0x00, 0x30, 0x00, 0x01, 0x00, 0x01, 0x51, 0x80, 0x01, 0x08, 0x01, 0x01, 0x03, 0x08, 0x03, 0x01, 0x00, 0x01, 0xac, 0xff, 0xb4, 0x09, 0xbc, 0xc9, 0x39, 0xf8, 0x31, 0xf7, 0xa1, 0xe5, 0xec, 0x88, 0xf7, 0xa5, 0x92, 0x55, 0xec, 0x53, 0x04, 0x0b, 0xe4, 0x32, 0x02, 0x73, 0x90, 0xa4, 0xce, 0x89, 0x6d, 0x6f, 0x90, 0x86, 0xf3, 0xc5, 0xe1, 0x77, 0xfb, 0xfe, 0x11, 0x81, 0x63, 0xaa, 0xec, 0x7a, 0xf1, 0x46, 0x2c, 0x47, 0x94, 0x59, 0x44, 0xc4, 0xe2, 0xc0, 0x26, 0xbe, 0x5e, 0x98, 0xbb, 0xcd, 0xed, 0x25, 0x97, 0x82, 0x72, 0xe1, 0xe3, 0xe0, 0x79, 0xc5, 0x09, 0x4d, 0x57, 0x3f, 0x0e, 0x83, 0xc9, 0x2f, 0x02, 0xb3, 0x2d, 0x35, 0x13, 0xb1, 0x55, 0x0b, 0x82, 0x69, 0x29, 0xc8, 0x0d, 0xd0, 0xf9, 0x2c, 0xac, 0x96, 0x6d, 0x17, 0x76, 0x9f, 0xd5, 0x86, 0x7b, 0x64, 0x7c, 0x3f, 0x38, 0x02, 0x9a, 0xbd, 0xc4, 0x81, 0x52, 0xeb, 0x8f, 0x20, 0x71, 0x59, 0xec, 0xc5, 0xd2, 0x32, 0xc7, 0xc1, 0x53, 0x7c, 0x79, 0xf4, 0xb7, 0xac, 0x28, 0xff, 0x11, 0x68, 0x2f, 0x21, 0x68, 0x1b, 0xf6, 0xd6, 0xab, 0xa5, 0x55, 0x03, 0x2b, 0xf6, 0xf9, 0xf0, 0x36, 0xbe, 0xb2, 0xaa, 0xa5, 0xb3, 0x77, 0x8d, 0x6e, 0xeb, 0xfb, 0xa6, 0xbf, 0x9e, 0xa1, 0x91, 0xbe, 0x4a, 0xb0, 0xca, 0xea, 0x75, 0x9e, 0x2f, 0x77, 0x3a, 0x1f, 0x90, 0x29, 0xc7, 0x3e, 0xcb, 0x8d, 0x57, 0x35, 0xb9, 0x32, 0x1d, 0xb0, 0x85, 0xf1, 0xb8, 0xe2, 0xd8, 0x03, 0x8f, 0xe2, 0x94, 0x19, 0x92, 0x54, 0x8c, 0xee, 0x0d, 0x67, 0xdd, 0x45, 0x47, 0xe1, 0x1d, 0xd6, 0x3a, 0xf9, 0xc9, 0xfc, 0x1c, 0x54, 0x66, 0xfb, 0x68, 0x4c, 0xf0, 0x09, 0xd7, 0x19, 0x7c, 0x2c, 0xf7, 0x9e, 0x79, 0x2a, 0xb5, 0x01, 0xe6, 0xa8, 0xa1, 0xca, 0x51, 0x9a, 0xf2, 0xcb, 0x9b, 0x5f, 0x63, 0x67, 0xe9, 0x4c, 0x0d, 0x47, 0x50, 0x24, 0x51, 0x35, 0x7b, 0xe1, 0xb5, 0x00, 0x00, 0x30, 0x00, 0x01, 0x00, 0x01, 0x51, 0x80, 0x01, 0x08, 0x01, 0x00, 0x03, 0x08, 0x03, 0x01, 0x00, 0x01, 0xe9, 0xed, 0x09, 0xc2, 0x04, 0x9d, 0xd2, 0xe1, 0xd9, 0x04, 0x8a, 0xfa, 0x91, 0xc5, 0xab, 0xf3, 0xe4, 0x28, 0x2c, 0x22, 0xa3, 0x1b, 0x7b, 0xe5, 0xde, 0xea, 0x34, 0xe5, 0x2e, 0x4c, 0xf3, 0x28, 0xd0, 0x57, 0x2d, 0x7b, 0xf3, 0x5b, 0xc0, 0x33, 0xdb, 0xa1, 0xcb, 0xdb, 0x67, 0xf7, 0x8d, 0x6f, 0x94, 0x55, 0xff, 0x14, 0x1d, 0x6a, 0x96, 0x89, 0x01, 0x24, 0x3f, 0xa0, 0x32, 0xec, 0xab, 0x30, 0xf4, 0x1f, 0x5f, 0x89, 0x90, 0x73, 0x6e, 0xb8, 0xa7, 0x36, 0x24, 0xbb, 0x69, 0x33, 0x18, 0x38, 0x82, 0x54, 0x84, 0xe0, 0x29, 0xd1, 0x5d, 0x3d, 0x82, 0x9c, 0x54, 0xd6, 0xe4, 0x8c, 0x0e, 0x44, 0x42, 0xfe, 0xcd, 0xea, 0x99, 0x1f, 0x2e, 0xbc, 0x39, 0x7c, 0xb9, 0x9e, 0x05, 0xb9, 0x28, 0x02, 0xdb, 0x7a, 0xf4, 0x58, 0x46, 0x0f, 0xea, 0xda, 0xa1, 0x5e, 0xcd, 0x1b, 0x42, 0x49, 0x0d, 0x24, 0x9e, 0x6c, 0x8f, 0xc2, 0x01, 0x6c, 0x82, 0x15, 0x58, 0x2c, 0xac, 0x22, 0xd7, 0x5e, 0xa8, 0xc7, 0x01, 0x14, 0xe7, 0x26, 0x7a, 0x5b, 0xb9, 0xe9, 0x58, 0xcc, 0x6d, 0xe5, 0x9f, 0x90, 0xb3, 0xc7, 0x62, 0x3c, 0xd5, 0xab, 0x4b, 0x96, 0x97, 0x2e, 0x02, 0x6d, 0xad, 0x65, 0x06, 0x20, 0x8b, 0x85, 0x7e, 0xe6, 0x70, 0x5d, 0x8c, 0xe2, 0x19, 0x13, 0xff, 0xcf, 0x7a, 0x35, 0x11, 0xf3, 0x28, 0xf7, 0x36, 0x54, 0xd7, 0xd2, 0x8b, 0xa2, 0x99, 0x28, 0x2d, 0x75, 0xfb, 0x2e, 0xcf, 0xdd, 0x88, 0x25, 0xdd, 0x48, 0x47, 0x49, 0x5d, 0x3b, 0x45, 0x03, 0xcc, 0x34, 0xfc, 0xe2, 0x90, 0xbe, 0x2b, 0x89, 0x79, 0xb7, 0xca, 0xb1, 0xca, 0x04, 0x94, 0x24, 0xec, 0xc2, 0xe9, 0x15, 0x67, 0x55, 0x57, 0xe6, 0x06, 0xda, 0x14, 0x4a, 0x36, 0xc5, 0x68, 0x47, 0x27, 0xd5, 0x28, 0xeb, 0x7c, 0x18, 0x69, 0x39, 0x00, 0x00, 0x29, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ])
        let message = try Message(messageData: data)
        XCTAssertEqual(message.questions.count, 1)
        XCTAssertEqual(message.answers.count, 2)
        XCTAssertEqual(message.questions[0].name, ".")
        XCTAssertEqual(message.answers[0].name, ".")
        XCTAssertEqual(message.answers[0].ttlSeconds, 86400)
        XCTAssertEqual(message.answers[0].recordType, .DNSKEY)
        guard let data1 = message.answers[0].data as? DNSKEYRecordData else { fatalError("answer data incorrect type") }
        XCTAssertEqual(data1.algorithm, .RSA_SHA256)
        XCTAssertEqual(data1.keySigningKey, true)
        XCTAssertEqual(data1.zoneKey, true)
        XCTAssertEqual(data1.revoked, false)
        XCTAssertEqual(data1.keyTag, 20326)
        guard let data2 = message.answers[1].data as? DNSKEYRecordData else { fatalError("answer data incorrect type") }
        XCTAssertEqual(data1.algorithm, .RSA_SHA256)
        XCTAssertEqual(data1.keySigningKey, true)
        XCTAssertEqual(data1.zoneKey, true)
        XCTAssertEqual(data1.revoked, false)
        XCTAssertEqual(data2.keyTag, 30903)
    }

    func testParseDNSDSMessage() throws {
        let data = Data([ 0x2e, 0x28, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x64, 0x6e, 0x73, 0x06, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x00, 0x00, 0x2b, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x2b, 0x00, 0x01, 0x00, 0x00, 0x03, 0x84, 0x00, 0x24, 0xda, 0xec, 0x08, 0x02, 0x1b, 0x0a, 0x7e, 0x90, 0xaa, 0x6b, 0x1a, 0xc6, 0x5a, 0xa5, 0xb5, 0x73, 0xef, 0xc4, 0x4a, 0xbf, 0x6c, 0xb2, 0x55, 0x94, 0x44, 0x25, 0x1b, 0x99, 0x71, 0x03, 0xd2, 0xe4, 0x0c, 0x35, 0x1b, 0x08, 0x00, 0x00, 0x29, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ])
        let message = try Message(messageData: data)
        XCTAssertEqual(message.questions.count, 1)
        XCTAssertEqual(message.answers.count, 1)
        XCTAssertEqual(message.questions[0].name, "dns.google.")
        XCTAssertEqual(message.answers[0].name, "dns.google.")
        XCTAssertEqual(message.answers[0].ttlSeconds, 900)
        XCTAssertEqual(message.answers[0].recordType, .DS)
        guard let data = message.answers[0].data as? DSRecordData else { fatalError("answer data incorrect type") }
        XCTAssertEqual(data.algorithm, .RSA_SHA256)
        XCTAssertEqual(data.digestType, .SHA256)
        XCTAssertEqual(message.answers[0].description, "dns.google. 900 IN DS 56044 8 2 1b0a7e90aa6b1ac65aa5b573efc44abf6cb2559444251b997103d2e40c351b08")
    }

    func testParseDNSSECMessage() throws {
        let data = Data([ 0x7e, 0x66, 0x81, 0xa0, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x03, 0x64, 0x6e, 0x73, 0x06, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x00, 0x00, 0x01, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x56, 0x00, 0x04, 0x08, 0x08, 0x04, 0x04, 0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x56, 0x00, 0x04, 0x08, 0x08, 0x08, 0x08, 0xc0, 0x0c, 0x00, 0x2e, 0x00, 0x01, 0x00, 0x00, 0x01, 0x56, 0x00, 0x9e, 0x00, 0x01, 0x08, 0x02, 0x00, 0x00, 0x03, 0x84, 0x66, 0x13, 0x30, 0xe6, 0x65, 0xf6, 0x2f, 0xe6, 0xb1, 0x18, 0x03, 0x64, 0x6e, 0x73, 0x06, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x00, 0x26, 0xec, 0x29, 0x2a, 0x05, 0x88, 0xc1, 0x69, 0x68, 0xeb, 0x12, 0x0b, 0x8c, 0x3b, 0x01, 0x09, 0xc8, 0xde, 0x36, 0xc1, 0xa2, 0x68, 0x09, 0xce, 0x5a, 0x87, 0xb9, 0xc8, 0x2a, 0x55, 0x70, 0x2c, 0x91, 0x64, 0x77, 0x76, 0xc8, 0x42, 0xe6, 0xbc, 0x93, 0x33, 0x1a, 0x95, 0x24, 0xa6, 0x9a, 0x11, 0xa5, 0x65, 0x9d, 0x2b, 0x0d, 0xe3, 0xf0, 0x50, 0x85, 0x85, 0x1a, 0x0d, 0xf8, 0x84, 0x3c, 0xd3, 0xe7, 0xef, 0x2d, 0xcd, 0x5e, 0xee, 0xd6, 0x3f, 0xa9, 0x4f, 0xc8, 0x14, 0xd9, 0x84, 0xd2, 0xd3, 0x51, 0x84, 0x4e, 0x7f, 0x34, 0x07, 0x77, 0x94, 0x56, 0x9d, 0xa0, 0xb5, 0x21, 0x5f, 0x6a, 0x89, 0xed, 0x74, 0x2b, 0x32, 0x38, 0xbb, 0x78, 0xe4, 0x17, 0x6f, 0x8e, 0x42, 0x78, 0x52, 0xff, 0x8d, 0x97, 0xc4, 0xc0, 0xda, 0x33, 0x79, 0x6b, 0xb5, 0x1d, 0x05, 0x55, 0x1b, 0x1b, 0x5e, 0x95, 0x91, 0x00, 0x00, 0x29, 0x02, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00 ])
        let message = try Message(messageData: data)
        XCTAssertEqual(message.questions.count, 1)
        XCTAssertEqual(message.answers.count, 3)
        XCTAssertEqual(message.questions[0].name, "dns.google.")
        XCTAssertEqual(message.answers[0].name, "dns.google.")
        XCTAssertEqual(message.answers[1].name, "dns.google.")
        XCTAssertEqual(message.answers[2].name, "dns.google.")
        XCTAssertEqual(message.answers[0].ttlSeconds, 342)
        XCTAssertEqual(message.answers[1].ttlSeconds, 342)
        XCTAssertEqual(message.answers[2].ttlSeconds, 342)
        XCTAssertEqual(message.answers[0].recordType, .A)
        XCTAssertEqual(message.answers[1].recordType, .A)
        XCTAssertEqual(message.answers[2].recordType, .RRSIG)
        guard let data1 = message.answers[0].data as? ARecordData else { fatalError("answer data incorrect type") }
        guard let data2 = message.answers[1].data as? ARecordData else { fatalError("answer data incorrect type") }
        guard let data3 = message.answers[2].data as? RRSIGRecordData else { fatalError("answer data incorrect type") }
        XCTAssertEqual(data1.ipAddress, "8.8.4.4")
        XCTAssertEqual(data2.ipAddress, "8.8.8.8")
        XCTAssertEqual(data1.description, "8.8.4.4")
        XCTAssertEqual(data2.description, "8.8.8.8")
        XCTAssertEqual(message.answers[0].description, "dns.google. 342 IN A 8.8.4.4")
        XCTAssertEqual(message.answers[1].description, "dns.google. 342 IN A 8.8.8.8")
        XCTAssertEqual(data3.typeCovered, .A)
        XCTAssertEqual(data3.algorithm, .RSA_SHA256)
        XCTAssertEqual(data3.labelCount, 2)
        XCTAssertEqual(data3.ttlSeconds, 900)
        XCTAssertEqual(message.answers[2].description, "dns.google. 342 IN RRSIG 8 2 900 20240407234854 20240316234854 45336 dns.google. JuwpKgWIwWlo6xILjDsBCcjeNsGiaAnOWoe5yCpVcCyRZHd2yELmvJMzGpUkppoRpWWdKw3j8FCFhRoN+IQ80+fvLc1e7tY/qU/IFNmE0tNRhE5/NAd3lFadoLUhX2qJ7XQrMji7eOQXb45CeFL/jZfEwNozeWu1HQVVGxtelZE=")
        let signedData = try data3.signedData()
        XCTAssertEqual(signedData.hexEncodedString(), "0001080200000384661330e665f62fe6b11803646e7306676f6f676c6500")
    }

    func testParseDNSHTTPSMessage() throws {
        let data = Data([ 0x95, 0x29, 0x81, 0xa0, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x65, 0x63, 0x6e, 0x02, 0x69, 0x6f, 0x00, 0x00, 0x41, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x41, 0x00, 0x01, 0x00, 0x00, 0x01, 0x2c, 0x00, 0xa6, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x06, 0x02, 0x68, 0x33, 0x02, 0x68, 0x32, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x02, 0x01, 0xbb, 0x00, 0x04, 0x00, 0x08, 0x7f, 0x00, 0x00, 0x01, 0x7f, 0x00, 0x00, 0x02, 0x00, 0x05, 0x00, 0x5b, 0x00, 0x59, 0xfe, 0x0d, 0x00, 0x55, 0x05, 0x00, 0x20, 0x00, 0x20, 0xab, 0x61, 0x42, 0xd7, 0x2a, 0x8d, 0xd7, 0x43, 0x6b, 0xf8, 0x77, 0x88, 0x8d, 0xff, 0x80, 0x97, 0x3f, 0x48, 0xb6, 0xe8, 0x8d, 0xcb, 0xc0, 0xf6, 0x90, 0xd3, 0xb4, 0x66, 0x3e, 0x1b, 0xd0, 0x04, 0x00, 0x24, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x02, 0x00, 0x01, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x03, 0x00, 0x03, 0x00, 0x01, 0x00, 0x03, 0x00, 0x02, 0x00, 0x03, 0x00, 0x03, 0x00, 0x06, 0x65, 0x63, 0x6e, 0x2e, 0x69, 0x6f, 0x00, 0x00, 0x00, 0x06, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x29, 0x04, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ])
        let message = try Message(messageData: data)
        XCTAssertEqual(message.questions.count, 1)
        XCTAssertEqual(message.answers.count, 1)
        XCTAssertEqual(message.questions[0].name, "ecn.io.")
        XCTAssertEqual(message.answers[0].name, "ecn.io.")
        XCTAssertEqual(message.answers[0].ttlSeconds, 300)
        XCTAssertEqual(message.answers[0].recordType, .HTTPS)
        guard let data = message.answers[0].data as? HTTPSRecordData else { fatalError("answer data incorrect type") }
        XCTAssertEqual(data.priority, 1)
        XCTAssertEqual(data.target, ".")
        XCTAssertNotNil(data.alpn)
        XCTAssertTrue(data.alpn?.contains(.HTTP2) ?? false)
        XCTAssertTrue(data.alpn?.contains(.HTTP3) ?? false)
        XCTAssertEqual(data.port, 443)
        XCTAssertNotNil(data.ipv4Hint)
        XCTAssertNotNil(data.ipv6Hint)
        XCTAssertTrue(data.ipv4Hint?.contains("127.0.0.1") ?? false)
        XCTAssertTrue(data.ipv6Hint?.contains("::1") ?? false)
        XCTAssertTrue(data.ipv4Hint?.contains("127.0.0.2") ?? false)
        XCTAssertTrue(data.ipv6Hint?.contains("::2") ?? false)
        XCTAssertNotNil(data.ech)
        XCTAssertEqual(data.ech?.base64EncodedString(), "AFn+DQBVBQAgACCrYULXKo3XQ2v4d4iN/4CXP0i26I3LwPaQ07RmPhvQBAAkAAEAAQABAAIAAQADAAIAAQACAAIAAgADAAMAAQADAAIAAwADAAZlY24uaW8AAA==")
        XCTAssertEqual(data.description, "1 . no-default-alpn=\"\" alpn=\"h3,h2\" port=\"443\" ipv4hint=\"127.0.0.1,127.0.0.2\" ipv6hint=\"::1,::2\" ech=\"AFn+DQBVBQAgACCrYULXKo3XQ2v4d4iN/4CXP0i26I3LwPaQ07RmPhvQBAAkAAEAAQABAAIAAQADAAIAAQACAAIAAgADAAMAAQADAAIAAwADAAZlY24uaW8AAA==\"")
    }
}
